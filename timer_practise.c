#include <signal.h>#include <time.h>#include <stdio.h>#include <errno.h>/*int timer_create(clockid_t clockid, struct sigevent *sevp, timer_t *timerid);	Link with -lrt	clockid can be 		CLOCK_REALTIME 		CLOCK_MONOTONIC		CLOCK_PROCESS_CPUTIME_ID //process consumed time		CLOCK_THREAD_CPUTIME_ID //thread consumed time			sevp a sigevent structure to show what will do when timer expired		sevp.sigev_notify can fille with			SIGEV_NONE			SIGEV_SIGNAL				send a signal, the siginfo_t.si_code will be set to SI_TIMER			SIGEV_THREAD			SIGEV_THREAD_ID	int timer_settime(timer_t timerid, int flags,				 const struct itimerspec *new_value,				 struct itimerspec * old_value);int timer_gettime(timer_t timerid, struct itimerspec *curr_value);	           struct timespec {               time_t tv_sec;                // Seconds                long   tv_nsec;               // Nanoseconds           };           struct itimerspec {               struct timespec it_interval;  // Timer interval               struct timespec it_value;     // Initial expiration           };	union sigval {          // Data passed with notification   int     sival_int;         // Integer value   void   *sival_ptr;         // Pointer value};struct sigevent {   int          sigev_notify; // Notification method   int          sigev_signo;  // Notification signal   union sigval sigev_value;  // Data passed with notification   void       (*sigev_notify_function) (union sigval);					// Function used for thread notification (SIGEV_THREAD)   void        *sigev_notify_attributes; // Attributes for notification thread(SIGEV_THREAD)   pid_t        sigev_notify_thread_id; // ID of thread to signal (SIGEV_THREAD_ID)};	it for notify the event	we only need to specified sigev_notify	sigev_notify can be		SIGEV_NONE//do not do anything when the event occurs		SIGEV_SIGNAL//Notify the process by sending signal 			the signal specified in sigev_signo field		SIGEV_THREAD			Notify the process by call sigev_notify_function as a new thread.			Function receive sigev_value as argument.			sigev_mptify_attributes can point a pthread_attr_t structure to define the thread attributes.		SIGEV_THREAD_ID			currently only use by POSIX timers.		*///since we do not have priority of interrupt, so we only use one RealTime Signal for all the interrupt//if we need the priority of interrupt, each module's interrupt should own it's own RealTime Signal#define DEBUG_ERROR_DETECT#define CYGWIN_ENV#define EMU_TIMER_CHANNEL_NUM 8#define SIGNAL_NUM (SIGRTMAX - SIGRTMIN + 1)//we are using real time signal, here is numbers of signal we can use#define EMU_SIGNAL_INT SIGRTMIN/*#if sizeof(long) < dEmu_SysInt_Number#error#endif#if (EMU_TIMER_CHANNEL_NUM > 8)#error#endif*/void Emu_TimerInt_Dispatch(int channel);void Emu_SysInt_Error_Dispatch(int channel);typedef void(*tEmu_IntDispatch_Func)(int channel);typedef void(*tEmu_InterruptHandler_Func)(void);enum Emu_System_Int{//should be in right order	dEmu_SysInt_Mcu = 0,	dEmu_SysInt_Timer,	dEmu_SysInt_Number//always the last element};//Used when Interrupt occur, and indicate which Interrupt it is exactlystruct Emu_IntIndicate{	unsigned char module;	unsigned char channel;};long gEmu_IntMask[dEmu_SysInt_Number];//First element is for system interrupt//long gEmu_IntFlag[dEmu_SysInt_Number];//First element is for system interruptstruct Emu_IntIndicate gEmu_IntIndicate_Current[dEmu_SysInt_Number][8];struct sigaction gEmu_Int_SA;tEmu_IntDispatch_Func oEmu_IntDispatch_Func[] = {//should be in right orderNULL,Emu_TimerInt_Dispatch};//==========================for timervoid Emu_TimerInt_Channel0Hander(void);void Emu_TimerInt_Channel1Hander(void);void Emu_TimerInt_Channel2Hander(void);void Emu_TimerInt_Channel3Hander(void);void Emu_TimerInt_Channel4Hander(void);void Emu_TimerInt_Channel5Hander(void);void Emu_TimerInt_Channel6Hander(void);void Emu_TimerInt_Channel7Hander(void);void Emu_TimerInt_Channel0Hander(void){	printf("0");}void Emu_TimerInt_Channel1Hander(void){	printf("1");}void Emu_TimerInt_Channel2Hander(void){	printf("2");}void Emu_TimerInt_Channel3Hander(void){	printf("3");}void Emu_TimerInt_Channel4Hander(void){	printf("4");}void Emu_TimerInt_Channel5Hander(void){	printf("5");}void Emu_TimerInt_Channel6Hander(void){	printf("6");}void Emu_TimerInt_Channel7Hander(void){	printf("7");}enum Emu_Timer_Int{//should be in right order	dEmu_TimerInt_C0 = 0,	dEmu_TimerInt_C1,	dEmu_TimerInt_C2,	dEmu_TimerInt_C3,	dEmu_TimerInt_C4,	dEmu_TimerInt_C5,	dEmu_TimerInt_C6,	dEmu_TimerInt_C7,	dEmu_TimerInt_Number//always the last element};timer_t gEmu_Timer_TimerArray[EMU_TIMER_CHANNEL_NUM];struct sigevent gEmu_Timer_SigEventArray[EMU_TIMER_CHANNEL_NUM];tEmu_InterruptHandler_Func gEmu_Timer_InterruptHandler_Func[] = {//should stay in a right orderEmu_TimerInt_Channel0Hander,Emu_TimerInt_Channel1Hander,Emu_TimerInt_Channel2Hander,Emu_TimerInt_Channel3Hander,Emu_TimerInt_Channel4Hander,Emu_TimerInt_Channel5Hander,Emu_TimerInt_Channel6Hander,Emu_TimerInt_Channel7Hander};//===================for system#define Emu_McuInt_IsEnable() \((gEmu_IntMask[dEmu_SysInt_Mcu] & (1 << dEmu_SysInt_Mcu))?1:0)/*no need to check IntFlag, because it will never be set#define Emu_McuInt_IsInt() \((gEmu_IntFlag[dEmu_SysInt_Mcu])?1:0)#define Emu_TimerInt_IsInt() \((gEmu_IntFlag[dEmu_SysInt_Timer])?1:0)*/#define Emu_McuInt_Enable() \(gEmu_Int_SA.sa_sigaction = Emu_SysInt_Dispatch, \(sigaction(EMU_SIGNAL_INT, &gEmu_Int_SA, NULL) < 0)?perror("McuInt Enable"):\gEmu_IntMask[dEmu_SysInt_Mcu] |= (1 << dEmu_SysInt_Mcu))#define Emu_McuInt_Disable() \(gEmu_Int_SA.sa_sigaction = SIG_IGN, \(sigaction(EMU_SIGNAL_INT, &gEmu_Int_SA, NULL) < 0)?perror("McuInt Disable"):\gEmu_IntMask[dEmu_SysInt_Mcu] &= (~(1 << dEmu_SysInt_Mcu)))//==============================for timer#define Emu_TimerInt_IsEnable() \((gEmu_IntMask[dEmu_SysInt_Mcu] & (1 << dEmu_SysInt_Timer))?1:0)#define Emu_TimerInt_IsChannelEnable(channel) \((gEmu_IntMask[dEmu_SysInt_Timer] & (1 << channel))?1:0)#define Emu_TimerInt_ChannelEnable(channel) \(gEmu_Timer_SigEventArray[channel].sigev_notify = Emu_TimerInt_Dispatch, \gEmu_IntMask[dEmu_SysInt_Timer] |= (1 << channel))#define Emu_TimerInt_ChannelDisable(channel) \(gEmu_Timer_SigEventArray[channel].sigev_notify = SIGEV_NONE, \gEmu_IntMask[dEmu_SysInt_Timer] &= (~(1 << channel)))//===================================for System===============================int Emu_SysInt_Init(void){	int result = 0;	int counter = 0;	int counter2 = 0;		for(counter = 0; counter < dEmu_SysInt_Number; counter ++)	{		gEmu_IntMask[counter] = 0;//		gEmu_IntFlag[counter] = 0;//no need to check IntFlag, it will never be set	}		for(counter = 0; counter < dEmu_SysInt_Number; counter ++)	{		for(counter2 = 0; counter2 < 8; counter2 ++)		{			gEmu_IntIndicate_Current[counter][counter2].module = counter;			gEmu_IntIndicate_Current[counter][counter2].channel = counter2;		}	}		gEmu_Int_SA.sa_sigaction = SIG_IGN;//it should be set emu_SysInt_Dispatch when enable the interrupt	gEmu_Int_SA.sa_flags = SA_SIGINFO;		result = sigaction(EMU_SIGNAL_INT, &gEmu_Int_SA, NULL);		if(result < 0)	{		perror("error to sigaction in System Interrupt init");	}		return result;}void Emu_SysInt_Dispatch(int sig_num, siginfo_t *siginfo, void * ucontext){	struct Emu_IntIndicate *current_IntIndicate = (siginfo->si_value).sival_ptr;	#ifdef DEBUG_ERROR_DETECT		if(sig_num == EMU_SIGNAL_INT)#endif	{#ifdef DEBUG_ERROR_DETECT			unsigned char module = current_IntIndicate->module;		unsigned char channel = current_IntIndicate->channel;		/* no need to check the IntFlag, because it will never be set		if(!gEmu_IntFlag[module] & (1 << channel))//check whether the IntFlag is right or not		{			printf("The IntFlag is not set, for module%d channel%d\n", module, channel);		}		*/		//check whether the IntMask of Whole system is disabled		if(!gEmu_IntMask[dEmu_SysInt_Mcu] & (1 << dEmu_SysInt_Mcu))		{			printf("Interrupt is triggered while IntMask of System is disabled\n");		}		//check whether the IntMask of module is right or not with the triggered interrupt		if(!gEmu_IntMask[module] & (1 << channel))		{			printf("The IntMask of Module is not set, for module%d channel%d\n", module, channel);		}		//check whether the IntMask of channel is right or not with the triggered interrupt		if(!gEmu_IntMask[dEmu_SysInt_Mcu] & (1 << module))		{			printf("The IntMask of Channel is not set, for module%d channel%d\n", module, channel);		}		//check whether the IntMask of module is same as sigevent.sigev_notify for timmer		if(gEmu_IntMask[dEmu_SysInt_Mcu] & (1 << dEmu_SysInt_Timer))		{//If timer int is enabled			int counter = 0;			int isNotifyEnable;			int isMaskEnable;			for(counter = 0; counter < EMU_TIMER_CHANNEL_NUM; counter ++)			{				isNotifyEnable = ((gEmu_Timer_SigEventArray + counter)->sigev_notify != SIGEV_NONE)?1:0;				isMaskEnable = (gEmu_IntMask[dEmu_SysInt_Timer] & (1 << counter))?1:0;								if(isNotifyEnable != isMaskEnable)				{					printf("timer channel IntMask is not correct in channel%d\n", counter);				}			}		}#endif			oEmu_IntDispatch_Func[current_IntIndicate->module](current_IntIndicate->channel);	}#ifdef DEBUG_ERROR_DETECT	else	{		printf("System Interrupt Dispatch received one unexpected signal %d", sig_num);	}#endif}void Emu_SysInt_Error_Dispatch(int channel){	printf("the module zero(system module) should not dispatch any interrupt\n\			Error Happened in IntMask or Handler of IntMask\n");}//=====================================for Timerint Emu_Timer_Init(timer_t *timer_array, struct sigevent *timer_sigevent_array, int channel_num){	int counter = 0;	int result = 0;		for(counter = 0; counter < EMU_TIMER_CHANNEL_NUM; counter ++)	{		(timer_sigevent_array + counter)->sigev_notify = SIGEV_NONE;//need to be change to SIGEV_SIGNAL when enable interrupt		(timer_sigevent_array + counter)->sigev_signo = EMU_SIGNAL_INT;		((timer_sigevent_array + counter)->sigev_value).sival_ptr = 			&gEmu_IntIndicate_Current[dEmu_SysInt_Timer][counter];				result = timer_create(CLOCK_REALTIME, timer_sigevent_array + counter, timer_array + counter);				if(result < 0)		{			perror("when timer_create");			break;		}	}		return result;}void Emu_Timer_SetStart(timer_t timer_id, struct timespec* time, int isrepeat){}void Emu_Timer_Stop(timer_t timer_id){}void Emu_Timer_Start(timer_t timer_id){}void Emu_Timer_Delete(timer_t *timer_array){	int result;	int counter = 0;		for(counter = 0; counter < EMU_TIMER_CHANNEL_NUM; counter ++)	{		result = timer_delete(*(timer_array + counter));				if(result < 0)		{			perror("timer%d delete error", counter);		}	}}int Emu_TimerInt_ModuleEnalbe(void){	int counter = 0;		gEmu_IntMask[dEmu_SysInt_Mcu] |= (1 << dEmu_SysInt_Timer);	for(counter = 0; counter < EMU_TIMER_CHANNEL_NUM; counter ++)	{		if(Emu_TimerInt_IsChannelEnable(counter))		{//if the channel is enabled			(gEmu_Timer_SigEventArray + counter)->sigev_notify = Emu_TimerInt_Dispatch;		}		else		{//if the channel is disabled			(gEmu_Timer_SigEventArray + counter)->sigev_notify = SIGEV_NONE;		}	}}int Emu_TimerInt_ModuleDisalbe(void){	int counter = 0;		gEmu_IntMask[dEmu_SysInt_Mcu] &= (~(1 << dEmu_SysInt_Timer));	for(counter = 0; counter < EMU_TIMER_CHANNEL_NUM; counter ++)	{		(gEmu_Timer_SigEventArray + counter)->sigev_notify = SIGEV_NONE;	}	}void Emu_TimerInt_Dispatch(int channel){	gEmu_Timer_InterruptHandler_Func[channel]();}int main(int argc, char **argv){	Emu_SysInt_Init();	Emu_Timer_Init(gEmu_Timer_TimerArray, gEmu_Timer_SigEventArray, EMU_TIMER_CHANNEL_NUM);		Emu_McuInt_Enable();		Emu_McuInt_Disable();		return 0;}